'' =================================================================================================''  library for parsing value'' =================================================================================================pub ucase(c) '' Convert c to uppercase'' -- does not modify non-alphas  if ((c => "a") and (c =< "z"))    c -= 32  return c  pub asc2val(pntr) | c'' Returns value of numeric string'' -- binary (%) and hex ($) must be indicated  repeat    c := byte[pntr]    case c       " ":                                                      ' skip leading space(s)            pntr++      "-", "0".."9":                                            ' found decimal value        return asc2dec(pntr, 11)      "%":                                                      ' found binary value        return bin2dec(pntr, 32)      "$":                                                      ' found hex value        return hex2dec(pntr, 8)            other:                                                    ' abort on bad character        return 0pub asc2dec(spntr, n) | c, value, sign'' Returns signed value from decimal string'' -- pntr is pointer to decimal string'' -- n is maximum number of digits to process  if (n < 1)                                                    ' if bogus, bail out    return 0   repeat    c := byte[spntr]    case c       " ":                                                      ' skip leading space(s)        spntr++      "-", "0".."9":                                            ' found value        if (c == "-")                                           ' sign symbol?          sign := -1                                            '  yes, set sign          spntr++                                               '  advance pointer        else          sign := 1                                             ' value is positive        quit      other:                                                    ' abort on bad character        return 0          value := 0  n <#= 10                                                      ' limit chars in value    repeat while (n)    c := byte[spntr++]                                              case c      "0".."9":                                                 ' digit?        value := (value * 10) + (c - "0")                       '  update value        n--                                                     '  dec digits count      "_":        ' skip      other:        quit  return sign * value       pub bin2dec(spntr, n) | c, value'' Returns value from {indicated} binary string'' -- pntr is pointer to binary string'' -- n is maximum number of digits to process  if (n < 1)                                                    ' if bogus, bail out    return 0   repeat    c := byte[spntr]    case c       " ":                                                      ' skip leading space(s)         spntr++      "%":                                                      ' found indicator        spntr++                                                 '  move to value        quit            "0".."1":                                                 ' found value        quit      other:                                                    ' abort on bad character        return 0  value := 0  n <#= 32                                                      ' limit chars in value  repeat while (n)                                                                          c := byte[spntr++]                                          ' get next character    case c      "0".."1":                                                 ' binary digit?        value := (value << 1) | (c - "0")                       '  update value        --n                                                     '  dec digits count      "_":        ' skip      other:        quit      return valuepub hex2dec(pntr, n) | c, value'' Returns value from {indicated} hex string'' -- pntr is pointer to binary string'' -- n is maximum number of digits to process  if (n < 1)                                                    ' if bogus, bail out    return 0   repeat    c := ucase(byte[pntr])    case c       " ":                                                      ' skip leading space(s)        pntr++      "$":                                                      ' found indicator        pntr++                                                  '  move to value        quit        "0".."9", "A".."F":                                       ' found value        quit       other:                                                    ' abort on bad character        return 0  value := 0  n <#= 8                                                       ' limit field width  repeat while (n)    c := ucase(byte[pntr++])    case c      "0".."9":                                                 ' digit?        value := (value << 4) | (c - "0")                       '  update value        --n                                                     '  dec digits count      "A".."F":                                                 ' hex digit?        value := (value << 4) | (c - "A" + 10)         --n      "_":        ' skip      other:        quit   return value   